#! /usr/bin/env python

################################################################################
#
# Copyright (c) 2009 The MadGraph Development team and Contributors
#
# This file is a part of the MadGraph 5 project, an application which 
# automatically generates Feynman diagrams and matrix elements for arbitrary
# high-energy processes in the Standard Model and beyond.
#
# It is subject to the MadGraph license which should accompany this 
# distribution.
#
# For more information, please visit: http://madgraph.phys.ucl.ac.be
#
################################################################################

"""This is the main executable, a simple frontend to set up the PYTHONPATH
and call immediately the command line interface scripts"""

import sys
if not sys.version_info[0] == 2 or sys.version_info[1] < 6:
    sys.exit('MadGraph 5 works only with python 2.6 or later (but not python 3.X).\n\
               Please upgrate your version of python.')

import os
import optparse

# Get the parent directory (mg root) of the script real path (bin)
# and add it to the current PYTHONPATH

root_path = os.path.split(os.path.dirname(os.path.realpath( __file__ )))[0]
sys.path.insert(0, root_path)


# Write out nice usage message if called with -h or --help
usage = "usage: %prog [options] [FILE] "
parser = optparse.OptionParser(usage=usage)
parser.add_option("-l", "--logging", default='INFO',
                  help="logging level (DEBUG|INFO|WARNING|ERROR|CRITICAL) [%default]")
parser.add_option("-f", "--file", default='',
                    help="Use script file FILE")
parser.add_option("-d", "--mgme_dir", default='', dest = 'mgme_dir',
                  help="Use MG_ME directory MGME_DIR")
parser.add_option("","--web", action="store_true", default=False, dest='web', \
                 help='force to be in secure mode')
parser.add_option("","--debug", action="store_true", default=False, dest='debug', \
                 help='force to launch debug mode')
(options, args) = parser.parse_args()
if len(args) == 0:
    args = ''

import subprocess

# Check if optimize mode is (and should be) activated
if __debug__ and not options.debug and \
    (not os.path.exists(os.path.join(root_path, 'bin','create_release.py')) or options.web):
        subprocess.call([sys.executable] + ['-O'] + sys.argv)
        sys.exit()

import logging
import logging.config
import madgraph.interface.coloring_logging


#
# Check if MG5 is up-to-date
#
if os.path.exists(os.path.join(root_path,'input','.autoupdate')):
    import signal
    import time
    import urllib
    data = {}
    for line in open(os.path.join(root_path,'input','.autoupdate')):
        sline = line.split()
        data[sline[0]] = int(sline[1])
    if time.time() - data['last_check'] > 7 * 24 *3600:
        print 'Checking if MG5 is up-to-date...'
        class TimeOutError(Exception): pass
        
        def handle_alarm(signum, frame): 
            raise TimeOutError
        
        signal.signal(signal.SIGALRM, handle_alarm)
        signal.alarm(2)
        to_update = 0
        try:
            filetext = urllib.urlopen('http://madgraph.phys.ucl.ac.be/mg5_build_nb')
            signal.alarm(0)
            web_version = int(filetext.read())            
        except (TimeOutError, ValueError):
            print 'failed to connect server'
        else:
            if web_version == data['version_nb']:
                print 'up-to-dated'
                fsock = open(os.path.join(root_path,'input','.autoupdate'),'w')
                fsock.write("version_nb   %s\n" % data['version_nb'])
                fsock.write("last_check   %s\n" % int(time.time()))
                fsock.close()
            elif data['version_nb'] > web_version:
                print 'impossible to update'
            else:
                out = raw_input('New Version of MG5 available! Do you want to update your current version? (y/n)')
                if out == 'y': 
                    to_update = True
        
        if to_update:
            print 'start updating code'
            fail = 0
            for i in range(data['version_nb'], web_version):
                try:
                    filetext = urllib.urlopen('http://madgraph.phys.ucl.ac.be/patch/.patch')
                except:
                    print 'fail to load patch to build #%s' % (i+1)
                    fail = i
                    break
                subprocess.call(['patch', '-b' '-p1'], stdin=filetext, 
                                                                  cwd=root_path)
            if fail != data['version_nb']:
                print 'checking current version. (type ctrl-c to bypass the check)'
                subprocess.call([os.path.join('tests','test_manager.py'],
                                                                  cwd=root_path)
            
            fsock = open(os.path.join(root_path,'input','.autoupdate'),'w')
            if not fail:
                fsock.write("version_nb   %s\n" % web_version)
            else:
                fsock.write("version_nb   %s\n" % fail)
            fsock.write("last_check   %s\n" % int(time.time()))
            fsock.close()        
        
        
        
try: 
    import readline
except ImportError:
    try:
        import pyreadline as readline
    except:
        print "For tab completion and history, install module readline."
else:
    import rlcompleter

    if 'r261:67515' in sys.version and  'GCC 4.2.1 (Apple Inc. build 5646)' in sys.version:
        readline.parse_and_bind("bind ^I rl_complete")
        readline.__doc__ = 'libedit'  
    
    elif hasattr(readline, '__doc__'):
        if 'libedit' not in readline.__doc__:
            readline.parse_and_bind("tab: complete")
        else:
            readline.parse_and_bind("bind ^I rl_complete")
    else:
        readline.__doc__ = 'GNU'
        readline.parse_and_bind("tab: complete")
        
    # charge history file
    try:
        history_file = os.path.join(os.environ['HOME'], '.mg5', 'mg5history')
        readline.read_history_file(history_file)
    except:
        pass

try:
   import psyco
   psyco.full()
except:
   pass

if __debug__:
        print 'Running MG5 in debug mode'


# Set logging level according to the logging level given by options
#logging.basicConfig(level=vars(logging)[options.logging])
try:
    if __debug__ and options.logging == 'INFO':
        options.logging = 'DEBUG'    
    logging.config.fileConfig(os.path.join(root_path, 'madgraph', 'interface', '.mg5_logging.conf'))
    logging.root.setLevel(eval('logging.' + options.logging))
    logging.getLogger('madgraph').setLevel(eval('logging.' + options.logging))
except:
    pass
import madgraph.interface.master_interface as interface

# Call the cmd interface main loop
try:
    if options.file or args:
        # They are an input file 
        if args:
            input_file = os.path.realpath(args[0])
        else:
            input_file = os.path.realpath(options.file)
        if options.web:
            cmd_line = interface.MasterCmdWeb()
            cmd_line.debug_output = os.path.join(os.path.dirname(input_file),'generation.log')
            cmd_line.use_rawinput = False
            cmd_line.run_cmd('import ' + input_file)
        else:
            cmd_line = interface.MasterCmd(mgme_dir = options.mgme_dir)
            cmd_line.use_rawinput = False
            cmd_line.run_cmd('import ' + input_file)
    else:
        # Interactive mode
        if options.web:
            cmd_line = interface.MasterCmdWeb()
            cmd_line.cmdloop()
        else:
            cmd_line = interface.MasterCmd(mgme_dir = options.mgme_dir)
            cmd_line.cmdloop()
except KeyboardInterrupt:
    print 'writting history and quit on KeyboardInterrupt' 
    pass

try:
    cmd_line.exec_cmd('quit all', printcmd=False)
    readline.set_history_length(100)
    if not os.path.exists(os.path.join(os.environ['HOME'], '.mg5')):
        os.mkdir(os.path.join(os.environ['HOME'], '.mg5'))
    readline.write_history_file(history_file)
except Exception, error:
    pass


    
